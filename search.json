[{"title":"codeforces global round 18","date":"2021-12-25T06:18:45.000Z","url":"/2021/12/25/codeforces-global-round-18/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["codeforces","/tags/codeforces/"],["思维","/tags/%E6%80%9D%E7%BB%B4/"],["前缀和与差分","/tags/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"]],"categories":[["ACM进阶记录","/categories/ACM%E8%BF%9B%E9%98%B6%E8%AE%B0%E5%BD%95/"]],"content":"好久没有水博客了，现在在摸鱼，正好水一篇昨天邮箱里收到一封codeforces的比赛邀请，然后就在想正好是平安夜，可以打一打这个作为休息昨天写高数和电路写麻了然后记录一下我写的三道签到题 首先是最简单的第一题A. Closing The Gaptime limit per test:2 secondsmemory limit per test:256 megabytesinput:standard inputoutput:standard outputThere are n block towers in a row, where tower i has a height of ai. You’re part of a building crew, and you want to make the buildings look as nice as possible. In a single day, you can perform the following operation: Choose two indices i and j (1≤i,j≤n; i≠j), and move a block from tower i to tower j. This essentially decreases ai by 1 and increases aj by 1.You think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)−min(a). What’s the minimum possible ugliness you can achieve, after any number of days? InputThe first line contains one integer t (1≤t≤1000) — the number of test cases. Then t cases follow. The first line of each test case contains one integer n (2≤n≤100) — the number of buildings. The second line of each test case contains n space separated integers a1,a2,…,an (1≤ai≤10^7) — the heights of the buildings. OutputFor each test case, output a single integer — the minimum possible ugliness of the buildings. Exampleinput output 题目大意就是给一串数字，然后可以：给其中一个增加1以及另一个减小1。然后要求这串数字最大高度差的最小值。稍微想想就能发现只要总长度能被数字个数整除就是0，否则就是1。代码就很简单了 然后就是第二题，其实也很简单（（B. And It’s Non-Zerotime limit per test:2 secondsmemory limit per test:256 megabytesinput:standard inputoutput:standard outputYou are given an array consisting of all integers from [l,r] inclusive. For example, if l=2 and r=5, the array would be [2,3,4,5]. What’s the minimum number of elements you can delete to make the bitwise AND of the array non-zero? A bitwise AND is a binary operation that takes two equal-length binary representations and performs the AND operation on each pair of the corresponding bits. InputThe first line contains one integer t (1≤t≤10^4) — the number of test cases. Then t cases follow. The first line of each test case contains two integers l and r (1≤l≤r≤2⋅10^5) — the description of the array. OutputFor each test case, output a single integer — the answer to the problem. Exampleinput output 大意是输入一个区间，求一个最小数a，删掉区间里的a个数后能使得区间内每个数按位与得到的值不为0。身为蒟蒻的我第一次提交超时惹这个数据量应该先打好表，然后用前缀和。也就是算出从1到n中二进制下31位（实际上没有31位）上各个位置1出现的次数。代码如下 最后是我写出来的最后一道签到题C. Menorahtime limit per test：2 secondsmemory limit per test：256 megabytesinput：standard inputoutput：standard outputThere are n candles on a Hanukkah menorah, and some of its candles are initially lit. We can describe which candles are lit with a binary string s, where the i-th candle is lit if and only if si=1. Initially, the candle lights are described by a string a. In an operation, you select a candle that is currently lit. By doing so, the candle you selected will remain lit, and every other candle will change (if it was lit, it will become unlit and if it was unlit, it will become lit). You would like to make the candles look the same as string b. Your task is to determine if it is possible, and if it is, find the minimum number of operations required. InputThe first line contains an integer t (1≤t≤10^4) — the number of test cases. Then t cases follow. The first line of each test case contains a single integer n (1≤n≤10^5) — the number of candles. The second line contains a string a of length n consisting of symbols 0 and 1 — the initial pattern of lights. The third line contains a string b of length n consisting of symbols 0 and 1 — the desired pattern of lights. It is guaranteed that the sum of n does not exceed 10^5. OutputFor each test case, output the minimum number of operations required to transform a to b, or −1 if it’s impossible. Exampleinput output 题目大意：给一串蜡烛，有的亮有的灭，要求你使得这串蜡烛所处的状态和要求的状态相同。0和1分别表示蜡烛的亮和灭。现在可以进行一种操作：保持一盏亮着的蜡烛状态不变，并使其他所有蜡烛变为它现在相反的状态。要求最少次数操作使得达成上述目的。乍一看感觉很复杂，但是仔细思考我们发现：我们可以通过两步操作交换一盏亮着的蜡烛和一盏暗着的蜡烛的状态；以及我们可以通过一步操作使得现在亮着的蜡烛的个数变为先前暗着的蜡烛的个数+1。那么我们可以得出结论：当要求状态的亮着的蜡烛个数b不等于原状态亮着的蜡烛的个数a、且b不等于原状态暗着的蜡烛个数p+1时，则不可能达到要求状态。此时要求解问题就很简单了，详见代码： 然后就水完了一篇博客以后可能会经常参加这种比赛，加油到以后某一天说不定就能AK了呢想peach"},{"title":"C语言实现优先队列","date":"2021-12-04T14:26:40.000Z","url":"/2021/12/04/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["二叉堆","/tags/%E4%BA%8C%E5%8F%89%E5%A0%86/"],["STL","/tags/STL/"],["C语言","/tags/C%E8%AF%AD%E8%A8%80/"]],"categories":[["ACM进阶记录","/categories/ACM%E8%BF%9B%E9%98%B6%E8%AE%B0%E5%BD%95/"]],"content":"起源先吐槽一下我的c语言老师，虽说快期末了，但是一下放40道算法题是要怎样啊，而且还是挺有难度的(包括但不限于搜索，贪心，动态规划，以及接下来要讲的优先队列)。然后呢，在我狂暴刷题的时候遇到了这么一道题：先看题目标签，STL！！！，让我们用c语言写STL的题是不是有点过分！！！况且我们只是刚刚入门。再看题目，要得到最小总费用，明显，即每步都合并最小的两堆。结合STL标签的提示，只要用优先队列不断pop最小的两堆合成后push，循环往复直到队列元素只剩下1个为止，时间复杂度为O(NlogN)。C++代码如下 是不是非常简单然而无奈老师设置了只能用c语言提交，所以要么自己动手实现优先队列的操作，要么另寻他法。但是本蒟蒻又找不到别的好办法，所以决定想办法动手实现优先队列。而后上网冲浪得知，优先队列的实现利用了二叉堆。那么赶快动手实现叭 解决先说二叉堆是什么：这张图应该足以解释了也就是父节点总是不小于(或不大于)子节点的二叉树，很好理解叭。那么如何在数组中表示这些元素的位置呢？其实很简单，假设根节点位于0，则父节点为n时，左子节点为2*n+1，右子节点为2*n+2(即为左子节点+1)。而已知子节点为n时，其父节点为(n-1)/2。接下来，就是如何进行push和pop操作了。(以下为小顶堆为例)先说push操作，假设要在二叉堆heap中插入一个元素x，只需将其先放在heap的末尾，然后不断和其父节点比较，如果小于父节点，则交换二者、继续比较，否则停止。代码实现如下 再说pop操作，pop即是取出heap中的第一个元素，亦即根节点。pop出一个值很简单，重点在于如何找出替代根节点的值。为了不破坏整体结构，我们先选择最后一个元素取代根节点的值，然后不断和子节点中的较小值比较，如果其大于该较小值，则交换二者，否则停止。代码实现如下 实现了这两个操作，再解决这题就很简单惹~~~完整代码如下 "},{"title":"敬启","date":"2021-11-24T15:30:52.000Z","url":"/2021/11/24/%E6%95%AC%E5%90%AF/","tags":[["杂谈","/tags/%E6%9D%82%E8%B0%88/"],["日常","/tags/%E6%97%A5%E5%B8%B8/"]],"categories":[["杂谈","/categories/%E6%9D%82%E8%B0%88/"]],"content":"敬启：敬是表示对收信人的尊敬，启是开启的意思。敬启就是请尊敬的收信人开启。有时也用在信的开头，这里的启就成了“开”的意思，就是请尊敬的收信人开始阅读。这是我博客搭建以来所写的第一篇文章，在写这篇文章的同时我也正开始学Markdown的语法，故而此文又兼具测试意义。 # 我为什么搭建博客自从离开Twitter已经大概两个月了叭，离开的原因很多我便不于此赘述，推特原本是我发表自己想法的一个很好的平台。虽然国内很多平台（包括某空间，某站还有某乎等等）看起来也都适于我发表想法，然而受困于交际圈等等各种原因，我不认为我的想法能被其中的人们广泛理解，甚至于给我带来不利的影响。而自己的Blog的受众则可由自己来选择，不必担心有他人的误解种种，而且有较强的独立性，更适于我的发挥。总之，此Blog主要用于我的一些想法的存储，还有平时一些事情的记录还有碎碎念。 # 这里有什么 计算机学习与程序开发这个可能有点早了（逃）的问题与发现与想法 文学与哲学方面的思考见解，阅读某作品后的感想 无关紧要的琐事 碎碎念 # 我是什么样的人既然能看到我的博客，那大概已经对我有一定的了解了。对于一部分人：我是计算机类的入门小白，正在不断学习，有打ACM竞赛的想法，目前在学算法入门、c++、python，准备学JavaScript、Java，想成为全能型选手（雾）对于另一部分人：我是（伪）文学少女，最喜欢的作家是芥川龙之介和夏目漱石，偏爱近现代文学对于极小部分人：我是无政府主义者 暂时就写这些叭，有想到的会再补上（逃）"}]