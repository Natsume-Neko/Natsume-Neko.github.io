[{"title":"再读夏目漱石《草枕》","date":"2022-03-30T16:13:04.000Z","url":"/2022/03/31/%E5%86%8D%E8%AF%BB%E3%80%8A%E8%8D%89%E6%9E%95%E3%80%8B/","tags":[["杂谈","/tags/%E6%9D%82%E8%B0%88/"],["书摘","/tags/%E4%B9%A6%E6%91%98/"]],"categories":[["书摘","/categories/%E4%B9%A6%E6%91%98/"]],"content":"《草枕》一直是我最喜欢的文学作品之一，其不仅仅是一本小说，而更是一首诗、一幅画。再读《草枕》，只因于忙碌的人世、为人带来痛苦的人情世界中感到疲倦，想品读此文以获慰藉。 一 发挥才智，则锋芒毕露；凭借感情，则流于世俗；坚持己见，则多方掣肘。总之，人世难居。 确然，人世难以安居，活于此世，便免不得他人的猜忌、免不得接受与给予他人人情、亦免不得因无谓的原因受到无端的攻击。人世难居却又无以迁移，于此人世，唯有诗与画能够带来些许慰藉、使人获得些许安然。 人世难居而又不可迁离，那就只好于此难居之处尽量求得宽舒，以便使短暂的生命在短暂的时光里过得顺畅些。于是，诗人的天职产生了，画家的使命降临了。一切艺术之士之所以尊贵，正因为他们能使人世变得娴静，能使人心变得丰富。 存于此世，若仅仅去追求物质上的富足，人心便会变得浮躁而空虚。何物以平静而充实人心？唯有文学与艺术。俗世之痛苦将被诗所抚平，人情之烦恼将被歌所带走。诗歌书画会于人的心中创造一个宁静的、无羁绊的、独一无二的崭新世界，而使人隔于俗世。于此隔绝的乾坤，大概人将活得比沉溺于俗世的任何一人都更加幸福罢。 欢乐愈多则忧愁愈深；幸福越大则痛苦越剧。 人世间，矛盾遍存，立于太阳之下，便一定存在影子。今日的欢乐即是明日的忧愁，此刻的幸福掩埋着将来的痛苦。过去与现在、今日与将来，其关系不仅仅存着因果，而更隐藏着矛盾。 当我把有形的自己忘却尽净、用纯客观的眼光看待一切的时候，我才能作为一个画中人和自然景物保持着协调的美。但是在感到雨天的苦恼、两腿疲惫不堪的时候，才发现自己既不是诗中人，也不是画中人。只不过仍然是市井中一分子。眼不见云烟飞动之趣，心不怀落花啼鸟之情，身冒潇潇大雨在春山上踽踽而行，我还是不理解究竟美在何处。起初是倾斜着帽子行走，后来只是望着脚趾甲行走，最终缩着肩膀战战兢兢地行走。雨摇撼着满眼的树梢，从四方袭来，威逼着天涯孤客，这种非人情实在太过分了。 生在凡世，便无法逃离凡世。非人情的世界是极美的，但我们却不能完全沉溺于其中。我们依然是有形的、依然为这物质的世界所束缚。我们并非诗画中的角色，亦非自然世界中的一分子， 我们无法遁入幻想之乾坤，亦无法化为云雀扎入云端消失形体并以灵魂鸣叫，我们依存凡身肉体。或许这便是我们与自然和艺术的矛盾之处罢。但是于此苦恼的人世，不时能有那非人情的自然与艺术，来治愈我虽竭力保护自己却仍已然伤痕累累的心，我便无比满足了。 待续"},{"title":"治愈","date":"2022-03-29T15:05:03.000Z","url":"/2022/03/29/%E8%BD%BB%E5%BE%AE%E6%94%BE%E6%9D%BE/","tags":[["杂谈","/tags/%E6%9D%82%E8%B0%88/"],["碎碎念","/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"]],"categories":[["碎碎念","/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"]],"content":"放下手头正忙的事，随手抽出《芥川龙之介全集》的一卷，又信手翻开一篇，无论是否读过、无论篇章长短，只是心无杂念看完此篇，便是对此时的我最好的治愈。"},{"title":"codeforces global round 18","date":"2021-12-25T06:18:45.000Z","url":"/2021/12/25/codeforces-global-round-18/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["codeforces","/tags/codeforces/"],["思维","/tags/%E6%80%9D%E7%BB%B4/"],["前缀和与差分","/tags/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"]],"categories":[["ACM进阶记录","/categories/ACM%E8%BF%9B%E9%98%B6%E8%AE%B0%E5%BD%95/"]],"content":"好久没有水博客了，现在在摸鱼，正好水一篇昨天邮箱里收到一封codeforces的比赛邀请，然后就在想正好是平安夜，可以打一打这个作为休息昨天写高数和电路写麻了然后记录一下我写的三道签到题 首先是最简单的第一题A. Closing The Gaptime limit per test:2 secondsmemory limit per test:256 megabytesinput:standard inputoutput:standard outputThere are n block towers in a row, where tower i has a height of ai. You’re part of a building crew, and you want to make the buildings look as nice as possible. In a single day, you can perform the following operation: Choose two indices i and j (1≤i,j≤n; i≠j), and move a block from tower i to tower j. This essentially decreases ai by 1 and increases aj by 1.You think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)−min(a). What’s the minimum possible ugliness you can achieve, after any number of days? InputThe first line contains one integer t (1≤t≤1000) — the number of test cases. Then t cases follow. The first line of each test case contains one integer n (2≤n≤100) — the number of buildings. The second line of each test case contains n space separated integers a1,a2,…,an (1≤ai≤10^7) — the heights of the buildings. OutputFor each test case, output a single integer — the minimum possible ugliness of the buildings. Exampleinput output 题目大意就是给一串数字，然后可以：给其中一个增加1以及另一个减小1。然后要求这串数字最大高度差的最小值。稍微想想就能发现只要总长度能被数字个数整除就是0，否则就是1。代码就很简单了 然后就是第二题，其实也很简单（（B. And It’s Non-Zerotime limit per test:2 secondsmemory limit per test:256 megabytesinput:standard inputoutput:standard outputYou are given an array consisting of all integers from [l,r] inclusive. For example, if l=2 and r=5, the array would be [2,3,4,5]. What’s the minimum number of elements you can delete to make the bitwise AND of the array non-zero? A bitwise AND is a binary operation that takes two equal-length binary representations and performs the AND operation on each pair of the corresponding bits. InputThe first line contains one integer t (1≤t≤10^4) — the number of test cases. Then t cases follow. The first line of each test case contains two integers l and r (1≤l≤r≤2⋅10^5) — the description of the array. OutputFor each test case, output a single integer — the answer to the problem. Exampleinput output 大意是输入一个区间，求一个最小数a，删掉区间里的a个数后能使得区间内每个数按位与得到的值不为0。身为蒟蒻的我第一次提交超时惹这个数据量应该先打好表，然后用前缀和。也就是算出从1到n中二进制下31位（实际上没有31位）上各个位置1出现的次数。代码如下 最后是我写出来的最后一道签到题C. Menorahtime limit per test：2 secondsmemory limit per test：256 megabytesinput：standard inputoutput：standard outputThere are n candles on a Hanukkah menorah, and some of its candles are initially lit. We can describe which candles are lit with a binary string s, where the i-th candle is lit if and only if si=1. Initially, the candle lights are described by a string a. In an operation, you select a candle that is currently lit. By doing so, the candle you selected will remain lit, and every other candle will change (if it was lit, it will become unlit and if it was unlit, it will become lit). You would like to make the candles look the same as string b. Your task is to determine if it is possible, and if it is, find the minimum number of operations required. InputThe first line contains an integer t (1≤t≤10^4) — the number of test cases. Then t cases follow. The first line of each test case contains a single integer n (1≤n≤10^5) — the number of candles. The second line contains a string a of length n consisting of symbols 0 and 1 — the initial pattern of lights. The third line contains a string b of length n consisting of symbols 0 and 1 — the desired pattern of lights. It is guaranteed that the sum of n does not exceed 10^5. OutputFor each test case, output the minimum number of operations required to transform a to b, or −1 if it’s impossible. Exampleinput output 题目大意：给一串蜡烛，有的亮有的灭，要求你使得这串蜡烛所处的状态和要求的状态相同。0和1分别表示蜡烛的亮和灭。现在可以进行一种操作：保持一盏亮着的蜡烛状态不变，并使其他所有蜡烛变为它现在相反的状态。要求最少次数操作使得达成上述目的。乍一看感觉很复杂，但是仔细思考我们发现：我们可以通过两步操作交换一盏亮着的蜡烛和一盏暗着的蜡烛的状态；以及我们可以通过一步操作使得现在亮着的蜡烛的个数变为先前暗着的蜡烛的个数+1。那么我们可以得出结论：当要求状态的亮着的蜡烛个数b不等于原状态亮着的蜡烛的个数a、且b不等于原状态暗着的蜡烛个数p+1时，则不可能达到要求状态。此时要求解问题就很简单了，详见代码： 然后就水完了一篇博客以后可能会经常参加这种比赛，加油到以后某一天说不定就能AK了呢想peach"},{"title":"C语言实现优先队列","date":"2021-12-04T14:26:40.000Z","url":"/2021/12/04/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["二叉堆","/tags/%E4%BA%8C%E5%8F%89%E5%A0%86/"],["STL","/tags/STL/"],["C语言","/tags/C%E8%AF%AD%E8%A8%80/"]],"categories":[["ACM进阶记录","/categories/ACM%E8%BF%9B%E9%98%B6%E8%AE%B0%E5%BD%95/"]],"content":"起源先吐槽一下我的c语言老师，虽说快期末了，但是一下放40道算法题是要怎样啊，而且还是挺有难度的(包括但不限于搜索，贪心，动态规划，以及接下来要讲的优先队列)。然后呢，在我狂暴刷题的时候遇到了这么一道题：先看题目标签，STL！！！，让我们用c语言写STL的题是不是有点过分！！！况且我们只是刚刚入门。再看题目，要得到最小总费用，明显，即每步都合并最小的两堆。结合STL标签的提示，只要用优先队列不断pop最小的两堆合成后push，循环往复直到队列元素只剩下1个为止，时间复杂度为O(NlogN)。C++代码如下 是不是非常简单然而无奈老师设置了只能用c语言提交，所以要么自己动手实现优先队列的操作，要么另寻他法。但是本蒟蒻又找不到别的好办法，所以决定想办法动手实现优先队列。而后上网冲浪得知，优先队列的实现利用了二叉堆。那么赶快动手实现叭 解决先说二叉堆是什么：这张图应该足以解释了也就是父节点总是不小于(或不大于)子节点的二叉树，很好理解叭。那么如何在数组中表示这些元素的位置呢？其实很简单，假设根节点位于0，则父节点为n时，左子节点为2*n+1，右子节点为2*n+2(即为左子节点+1)。而已知子节点为n时，其父节点为(n-1)/2。接下来，就是如何进行push和pop操作了。(以下为小顶堆为例)先说push操作，假设要在二叉堆heap中插入一个元素x，只需将其先放在heap的末尾，然后不断和其父节点比较，如果小于父节点，则交换二者、继续比较，否则停止。代码实现如下 再说pop操作，pop即是取出heap中的第一个元素，亦即根节点。pop出一个值很简单，重点在于如何找出替代根节点的值。为了不破坏整体结构，我们先选择最后一个元素取代根节点的值，然后不断和子节点中的较小值比较，如果其大于该较小值，则交换二者，否则停止。代码实现如下 实现了这两个操作，再解决这题就很简单惹~~~完整代码如下 "},{"title":"敬启","date":"2021-11-24T15:30:52.000Z","url":"/2021/11/24/%E6%95%AC%E5%90%AF/","tags":[["杂谈","/tags/%E6%9D%82%E8%B0%88/"],["日常","/tags/%E6%97%A5%E5%B8%B8/"]],"categories":[["杂谈","/categories/%E6%9D%82%E8%B0%88/"]],"content":"敬启：敬是表示对收信人的尊敬，启是开启的意思。敬启就是请尊敬的收信人开启。有时也用在信的开头，这里的启就成了“开”的意思，就是请尊敬的收信人开始阅读。这是我博客搭建以来所写的第一篇文章，在写这篇文章的同时我也正开始学Markdown的语法，故而此文又兼具测试意义。 # 我为什么搭建博客自从离开Twitter已经大概两个月了叭，离开的原因很多我便不于此赘述，推特原本是我发表自己想法的一个很好的平台。虽然国内很多平台（包括某空间，某站还有某乎等等）看起来也都适于我发表想法，然而受困于交际圈等等各种原因，我不认为我的想法能被其中的人们广泛理解，甚至于给我带来不利的影响。而自己的Blog的受众则可由自己来选择，不必担心有他人的误解种种，而且有较强的独立性，更适于我的发挥。总之，此Blog主要用于我的一些想法的存储，还有平时一些事情的记录还有碎碎念。 # 这里有什么 计算机学习与程序开发这个可能有点早了（逃）的问题与发现与想法 文学与哲学方面的思考见解，阅读某作品后的感想 无关紧要的琐事 碎碎念 # 我是什么样的人既然能看到我的博客，那大概已经对我有一定的了解了。对于一部分人：我是计算机类的入门小白，正在不断学习，有打ACM竞赛的想法，目前在学算法入门、c++、python，准备学JavaScript、Java，想成为全能型选手（雾）对于另一部分人：我是（伪）文学少女，最喜欢的作家是芥川龙之介和夏目漱石，偏爱近现代文学对于极小部分人：我是无政府主义者 暂时就写这些叭，有想到的会再补上（逃）"}]